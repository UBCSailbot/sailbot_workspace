{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/runtime/attachment_manager/index.ts"],"names":[],"mappings":"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","sourcesContent":["import isStream from 'is-stream'\nimport { Readable } from 'stream'\nimport * as messages from '@cucumber/messages'\nimport { doesHaveValue, doesNotHaveValue } from '../../value_checker'\n\nexport interface IAttachmentMedia {\n  encoding: messages.AttachmentContentEncoding\n  contentType: string\n}\n\nexport interface IAttachment {\n  data: string\n  media: IAttachmentMedia\n  fileName?: string\n}\n\nexport type IAttachFunction = (attachment: IAttachment) => void\n\nexport interface ICreateAttachmentOptions {\n  mediaType: string\n  fileName?: string\n}\nexport type ICreateStringAttachment = (\n  data: string,\n  mediaTypeOrOptions?: string | ICreateAttachmentOptions\n) => void\nexport type ICreateBufferAttachment = (\n  data: Buffer,\n  mediaTypeOrOptions: string | ICreateAttachmentOptions\n) => void\nexport type ICreateStreamAttachment = (\n  data: Readable,\n  mediaTypeOrOptions: string | ICreateAttachmentOptions\n) => Promise<void>\nexport type ICreateStreamAttachmentWithCallback = (\n  data: Readable,\n  mediaTypeOrOptions: string | ICreateAttachmentOptions,\n  callback: () => void\n) => void\nexport type ICreateAttachment = ICreateStringAttachment &\n  ICreateBufferAttachment &\n  ICreateStreamAttachment &\n  ICreateStreamAttachmentWithCallback\nexport type ICreateLog = (text: string) => void\n\nexport default class AttachmentManager {\n  private readonly onAttachment: IAttachFunction\n\n  constructor(onAttachment: IAttachFunction) {\n    this.onAttachment = onAttachment\n  }\n\n  log(text: string): void | Promise<void> {\n    return this.create(text, 'text/x.cucumber.log+plain')\n  }\n\n  create(\n    data: Buffer | Readable | string,\n    mediaTypeOrOptions?: string | ICreateAttachmentOptions,\n    callback?: () => void\n  ): void | Promise<void> {\n    const options = normaliseOptions(mediaTypeOrOptions)\n    if (Buffer.isBuffer(data)) {\n      if (doesNotHaveValue(options.mediaType)) {\n        throw Error('Buffer attachments must specify a media type')\n      }\n      this.createBufferAttachment(data, options.mediaType, options.fileName)\n    } else if (isStream.readable(data)) {\n      if (doesNotHaveValue(options.mediaType)) {\n        throw Error('Stream attachments must specify a media type')\n      }\n      return this.createStreamAttachment(\n        data,\n        options.mediaType,\n        options.fileName,\n        callback\n      )\n    } else if (typeof data === 'string') {\n      if (doesNotHaveValue(options.mediaType)) {\n        options.mediaType = 'text/plain'\n      }\n      if (options.mediaType.startsWith('base64:')) {\n        this.createStringAttachment(\n          data,\n          {\n            encoding: messages.AttachmentContentEncoding.BASE64,\n            contentType: options.mediaType.replace('base64:', ''),\n          },\n          options.fileName\n        )\n      } else {\n        this.createStringAttachment(\n          data,\n          {\n            encoding: messages.AttachmentContentEncoding.IDENTITY,\n            contentType: options.mediaType,\n          },\n          options.fileName\n        )\n      }\n    } else {\n      throw Error(\n        'Invalid attachment data: must be a buffer, readable stream, or string'\n      )\n    }\n  }\n\n  createBufferAttachment(\n    data: Buffer,\n    mediaType: string,\n    fileName?: string\n  ): void {\n    this.createStringAttachment(\n      data.toString('base64'),\n      {\n        encoding: messages.AttachmentContentEncoding.BASE64,\n        contentType: mediaType,\n      },\n      fileName\n    )\n  }\n\n  createStreamAttachment(\n    data: Readable,\n    mediaType: string,\n    fileName?: string,\n    callback?: () => void\n  ): void | Promise<void> {\n    const promise = new Promise<void>((resolve, reject) => {\n      const buffers: Uint8Array[] = []\n      data.on('data', (chunk) => {\n        buffers.push(chunk)\n      })\n      data.on('end', () => {\n        this.createBufferAttachment(Buffer.concat(buffers), mediaType, fileName)\n        resolve()\n      })\n      data.on('error', reject)\n    })\n    if (doesHaveValue(callback)) {\n      promise.then(callback, callback)\n    } else {\n      return promise\n    }\n  }\n\n  createStringAttachment(\n    data: string,\n    media: IAttachmentMedia,\n    fileName?: string\n  ): void {\n    this.onAttachment({\n      data,\n      media,\n      ...(fileName ? { fileName } : {}),\n    })\n  }\n}\n\nfunction normaliseOptions(\n  mediaTypeOrOptions?: string | ICreateAttachmentOptions\n): Partial<ICreateAttachmentOptions> {\n  if (!mediaTypeOrOptions) {\n    return {}\n  }\n  if (typeof mediaTypeOrOptions === 'string') {\n    return {\n      mediaType: mediaTypeOrOptions,\n    }\n  }\n  return mediaTypeOrOptions\n}\n"]}