{"version":3,"file":"formatCommand.js","sourceRoot":"","sources":["../../../src/commands/formatCommand.ts"],"names":[],"mappings":"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","sourcesContent":["import fs, { unlink as unlinkCb } from 'fs'\nimport path from 'path'\nimport * as messages from '@cucumber/messages'\nimport { AstBuilder, GherkinClassicTokenMatcher, GherkinInMarkdownTokenMatcher, Parser, } from '@cucumber/gherkin'\nimport pretty, { Syntax } from '../pretty'\nimport { promisify } from 'util'\nimport { Readable, Writable } from 'stream'\n\nconst unlink = promisify(unlinkCb)\n\nexport type FormatOptions = {\n  fromSyntax?: Syntax\n  toSyntax?: Syntax\n  language?: string\n}\n\ntype FileFormat = {\n  readableSyntax: Syntax\n  writableSyntax: Syntax\n  readable: () => Readable\n  writable: () => Writable\n  afterWrite: () => Promise<void>\n}\n\nexport async function formatCommand(\n  files: string[],\n  stdin: Readable | null,\n  stdout: Writable | null,\n  options: FormatOptions\n): Promise<void> {\n  const fileFormats: FileFormat[] = files.map(file => {\n    const toFile = syntaxPath(file, options.toSyntax)\n    return {\n      readableSyntax: syntaxFromPath(file, options.fromSyntax),\n      writableSyntax: syntaxFromPath(toFile, options.toSyntax),\n      readable: () => fs.createReadStream(file),\n      writable: () => fs.createWriteStream(toFile),\n      afterWrite: file !== toFile ? () => unlink(file) : () => Promise.resolve()\n    }\n  })\n  if (stdin && stdout) {\n    fileFormats.push({\n      readableSyntax: options.fromSyntax || 'gherkin',\n      writableSyntax: options.toSyntax || 'gherkin',\n      readable: () => stdin,\n      writable: () => stdout,\n      afterWrite: () => Promise.resolve()\n    })\n  }\n  for (const fileFormat of fileFormats) {\n    await convert(fileFormat, options.language)\n  }\n}\n\nasync function convert(fileFormat: FileFormat, language: string) {\n  const source = await read(fileFormat.readable())\n  const gherkinDocument = parse(source, fileFormat.readableSyntax, language)\n  const output = pretty(gherkinDocument, fileFormat.writableSyntax)\n  try {\n    // Sanity check that what we generated is OK.\n    parse(output, fileFormat.writableSyntax, gherkinDocument.feature?.language)\n  } catch (err) {\n    err.message += `The generated output is not parseable. This is a bug.\nPlease report a bug at https://github.com/cucumber/common/issues/new\n\n--- Generated ${fileFormat.writableSyntax} source ---\n${output}\n------\n`\n    throw err\n  }\n  const writable = fileFormat.writable()\n  writable.write(output)\n  writable.end()\n  await new Promise((resolve) => writable.once('finish', resolve))\n  await fileFormat.afterWrite()\n}\n\nfunction parse(source: string, syntax: Syntax, language: string) {\n  if (!syntax) throw new Error('No syntax')\n  const fromParser = new Parser(\n    new AstBuilder(messages.IdGenerator.uuid()),\n    syntax === 'gherkin'\n      ? new GherkinClassicTokenMatcher(language)\n      : new GherkinInMarkdownTokenMatcher(language)\n  )\n  return fromParser.parse(source)\n}\n\nasync function read(readable: Readable): Promise<string> {\n  const chunks = []\n  for await (const chunk of readable) chunks.push(chunk)\n  return Buffer.concat(chunks).toString('utf-8')\n}\n\nfunction syntaxPath(file: string, syntax: Syntax): string {\n  if (syntax === 'markdown') {\n    if (syntaxFromPath(file) === 'markdown') return file\n    return file + '.md'\n  }\n\n  if (syntax === 'gherkin') {\n    if (syntaxFromPath(file) === 'gherkin') return file\n    return file.replace(/\\.feature\\.md/, '.feature')\n  }\n\n  return file\n}\n\nfunction syntaxFromPath(file: string, explicitSyntax?: Syntax): Syntax {\n  let syntax: Syntax\n  if (path.extname(file) === '.feature') syntax = 'gherkin'\n  if (path.extname(file) === '.md') syntax = 'markdown'\n  if (!syntax) throw new Error(`Cannot determine syntax from path ${file}`)\n  if (explicitSyntax && explicitSyntax !== syntax) throw new Error(`Cannot treat ${file} as ${explicitSyntax}`)\n  return syntax\n}\n"]}