# Current Project Overview

Our current project, Polaris, is an autonomous research vessel capable of collecting oceanic and atmospheric data. With our
expertise in autonomous sailing, the goal is to monitor the health of our oceans while collaborating with stakeholders
and researchers involved in climate science and oceanography.

The software team is responsible for designing, implementing, and testing the software system of our autonomous sailboats.
We work on both low-level and high-level integration, from interfacing with sensors to planning sea routes with pathfinding
algorithms.

## Dataflow

The software architecture for our next autonomous sailboat is split across two computers: the on board computer on board
and the remote server off board. The following paragraphs will follow the flow of data between the software components
(bolded) on each computer.

On the remote server, **global pathfinding** uses the A* pathfinding algorithm to create a sailing path, a list of global
waypoints from the current position to destination. Global sailing paths are sent via the **Remote Transceiver** to the
**Local Transceiver** on the on board computer.

On the on board computer, the **CAN Transceiver** receives GPS and wind data from their respective sensors. This raw data
is filtered before being used in the other software components. **Local Pathfinding** uses GPS and wind data, as well as
the global path and AIS data from the **AIS Receiver**, to create a local path, a list of local waypoints from the current
position to the next global waypoint. The **Controller** uses wind data and the relative bearing to the local path to adjust
the rudder and sails accordingly. The state of the boat and research data we collect is sent via the **Local Transceiver**
to the **Remote Transceiver** on the remote server.

Back on the remote server, the **Website** presents the boat state and research data for monitoring and analysis purposes.
The **Remote Transceiver** additionally includes manual overrides such as resetting the boat state and modifying the global
path.

As for the communication mediums, the computers communicate via satellite, and components on the on board computer communicate
through the [Robot Operating System framework](../reference/ros.md){target=_blank}, or ROS for short.

For software development purposes, all software components will be able to run and communicate with each other locally.
To accomplish this, we will:

1. Create a development environment that has all software component dependencies: **Sailbot Workspace**.
2. Develop accurate simulations of the environment and hardware: **Simulator**, **Mock AIS**, **Mock Global Pathfinding**.
3. Add configuration options to select between real and simulated hardware as well as running remote server components
   remotely or locally.

## Diagrams

In these diagrams, the bubbles represent components of our software system, and the direction of arrows connecting the
bubbles represent the flow of data between them. The color of the bubbles denote the sub-team leading their development:

- Purple: Controls
- Green: Network Systems
- Blue: Pathfinding
- Red: Website
- White: Not a part of the Software Team's codebase

Components that are used in both the production and development environments are darker,
while ones that are only used in one are lighter.

!!! tip "Interacting with the diagram"

    - To switch between the production and development environment diagrams, hover over the image to make the toolbar
      visible and navigate with the arrows on the left side

<!-- This was generated by going to the source, selecting File > Embed > iFrame, and deselecting Layers, Tags, and Edit -->
<!-- Source: https://drive.google.com/file/d/1_qC245vcXXuB69TLDhcfBPzdc10g7hwi/view?usp=sharing -->
<iframe frameborder="0" style="width:100%;height:533px;" src="https://viewer.diagrams.net/?highlight=0000ff&nav=1&title=SOFT%20Architecture%20Diagram#Uhttps%3A%2F%2Fdrive.google.com%2Fuc%3Fid%3D1_qC245vcXXuB69TLDhcfBPzdc10g7hwi%26export%3Ddownload"></iframe>
